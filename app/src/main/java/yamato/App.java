/*
 * This source file was generated by the Gradle 'init' task
 */
package yamato;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;


public class App {
    
    // FILE_TYPE_NORMALは問１、FILE_TYPE_REVERSEは問２の処理に対応する
    private static int FILE_TYPE_NORMAL = 1;
    private static int FILE_TYPE_REVERSE = 2;

    /**
     * 各問に対する検証コマンド
     * 問1.java App.java "apple\tfruit:sale\nbanana:cherry\tfruit\n\tbeverage"
     * 問2.java App.java "fruit\tapple\nfruit\tbanana\nbeverage\t\nfruit\tbanana\nbeverage\tcoke\npet\tdog"
     *
     * @param args[0]   tsvデータ式で渡された、正規化済み、もしくは正規化前の文字列
     * @output 標準出力で結果を出力
     * @return 
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        int fileType = 0;
        if(args.length > 0) {
            System.out.println("tsvデータ式の文字列を読み込みました");
            // 標準入力を読み取る
            String[] eachLine = args[0].split("\\\\n",-1);
            for (String line : eachLine) {
                if(line.indexOf(":") != -1){
                    fileType = FILE_TYPE_NORMAL;
                    break;
                }
            }
            if(fileType == 0){
                fileType = FILE_TYPE_REVERSE;
            }

            // 標準入力のTSVデータのパターンに応じて正規化への変換、逆変換に分岐
            if(fileType == FILE_TYPE_NORMAL){
                App.standardizeTSV(args[0]);    
            }else if(fileType == FILE_TYPE_REVERSE){
                App.revrerseStandardizeTSV(args[0]);
            }
        }else{
            System.out.println("tsvデータ式の文字列を標準入力で与えてください");
        }
        return;
    }

    /** 1. 第一正規化 */
    public static void standardizeTSV(String tsvData) throws Exception{
        String[] eachLine = tsvData.split("\\\\n",-1);
        
        for (String line : eachLine) {
            // タブ区切りで列に分解
            String key = line.split("\\\\t", -1)[0];
            String value = line.split("\\\\t", -1)[1];
            // グループ区切りでさらに分解
            String[] keyContents = key.split(":", -1);
            String[] valueContents = value.split(":", -1);
            
            // 分解した列を正規化して出力
            for (String keyString : keyContents) {
                for (String valueString : valueContents) {
                    // 第一正規化を行ごとに出力
                    System.out.println(keyString + "\t" + valueString);
                }
            }
        }
    }

    /** 2.第一正規化の逆変換 */
    public static void revrerseStandardizeTSV(String tsvData) throws Exception{
        String[] eachLine = tsvData.split("\\\\n");
        // 2重配列でデータを集計
        Map<String, String> keyValueMap = new HashMap<>();
        String value = "";

        for (String line : eachLine) {
            // キー情報を集計
            String key = line.split("\\\\t", -1)[0];
            int linelength = line.split("\\\\t", -1).length;
            
            // 各グループごとに値を集計
            if(keyValueMap.containsKey(key)){
                StringBuilder sb = new StringBuilder();
                // 既にキーが存在する場合、今の行の値を「：」で連結して上書き
                sb.append(keyValueMap.get(key)).append(":").append(line.split("\\\\t", -1)[linelength - 1]);
                value = sb.toString();
                keyValueMap.put(key, value);
            }else{
                // キーが存在しない場合、新規グループ登録
                value = line.split("\\\\t", -1)[linelength - 1];
                keyValueMap.put(key, value);
            }
        }
        
        // Mapで集計済みになっているので、キーと値をタブ区切りで出力
        for (Entry<String, String> tsvOutput : keyValueMap.entrySet()) {
            System.out.println(tsvOutput.getKey() + "\t" + tsvOutput.getValue());
        }
    }
}
